use rand::Rng;
use std::mem;

pub enum Gate {
    // keep qubit indiciis as u32 for some
    // semblence of an upper bound on qubit type.
    // has the benefit of preparing the code to handle
    // type indirection between qubiut register vector indexing
    // (in usize) and qubit index (in u32 for now).
    H(u32),
    S(u32),
    Cx(u32, u32),
}

// TODO: const N is a choice. It makes things
// easy, but it means
// you can't determine the simulator size
// dynamically. This is something to fix
// later -- we should probably back storage
// by vectors.
#[derive(Debug)]
struct StabilizerRow<const N: usize> {
    phase_is_negated: bool,
    x_bits: [bool; N],
    z_bits: [bool; N],
}

// humble beginnings: slow stabilizer
// simulator that tracks stabilizers and
// destabilizers for n qubits, and supports
// h, s, and cnot.
pub struct StabilizerSimulator<const N: usize> {
    stabilizers: [StabilizerRow<N>; N],
    destabilizers: [StabilizerRow<N>; N],
    measured: [bool; N],
    rand: rand::rngs::StdRng,
}

impl<const N: usize> StabilizerSimulator<N> {
    pub fn new(seed: u64) -> StabilizerSimulator<N> {
        let mut initial_stabilizers: [StabilizerRow<N>; N] = unsafe { mem::zeroed() };
        let mut initial_destabilizers: [StabilizerRow<N>; N] = unsafe { mem::zeroed() };
        for i in 0..N {
            initial_stabilizers[i] = StabilizerRow {
                phase_is_negated: false,
                x_bits: [false; N],
                z_bits: [false; N],
            };
            initial_destabilizers[i] = StabilizerRow {
                phase_is_negated: false,
                x_bits: [false; N],
                z_bits: [false; N],
            };
        }

        // initialize the stabilizers and destabilziers of the
        // |0...0> state. -- Z stabilizes 0, and X destabilizes 0.
        // The generators for the stabilizers and
        // destabilizers are the product of terms like ZI*...*I and
        // XI*...*I, respectively. We just need N of each generator with
        // a single Z or X acting on each qubit. From there, all stabilizer
        // pauli strings can be generated by the product of these generators.
        for i in 0..N {
            initial_stabilizers[i].z_bits[i] = true;
            initial_destabilizers[i].x_bits[i] = true;
        }

        StabilizerSimulator {
            measured: [false; N],
            stabilizers: initial_stabilizers,
            destabilizers: initial_destabilizers,
            rand: rand::SeedableRng::seed_from_u64(seed),
        }
    }

    pub fn seeded() -> StabilizerSimulator<N> {
        StabilizerSimulator::new(0)
    }

    pub fn apply_gate(&mut self, gate: &Gate) {
        match gate {
            // TODO: I wonder if I should move the dispatch to a trait
            // on the gates enum. This is probably only important in a world
            // where I have multiple clients for the gate type, which seems
            // out of scope for this project.
            Gate::H(qubit) => {
                for i in 0..N {
                    // Hadamard acts on stabilizers and destabilizers homogenously, given that they maintain
                    // their relationship to each other as an invariant.
                    for generator in
                        [&mut self.stabilizers[i], &mut self.destabilizers[i]].iter_mut()
                    {
                        let generator_x_component = generator.x_bits[*qubit as usize];
                        let generator_z_component = generator.z_bits[*qubit as usize];
                        //H swaps X and Z components of the stabilizer. Y == -iZX, which we turn into
                        // -iXZ == -Y. So we just need to flip the sign of the stabilizer if it has both
                        // X and Z components.
                        // Otherwise, if you are stabilized by only X, you are one of |+> or |->. Hadamard
                        // Will simply map you to |0> |1> with the same generator phase. If you are stabilized
                        // by only Z, you are one of |0> or |1>. Hadamard will map you to |+> |-> with the same
                        // generator phase.
                        // In general, H maps X and Z stabilizer states to the Z and X stabilizer states, respectively,
                        // and with the same phase.
                        generator.phase_is_negated ^=
                            generator_x_component && generator_z_component;
                        mem::swap(
                            &mut generator.x_bits[*qubit as usize],
                            &mut generator.z_bits[*qubit as usize],
                        )
                    }
                }
            }
            Gate::S(qubit) => {
                for i in 0..N {
                    // S acts on stabilizers and destabilizers homogenously, given that they maintain
                    // their relationship to each other as an invariant.
                    for generator in
                        [&mut self.stabilizers[i], &mut self.destabilizers[i]].iter_mut()
                    {
                        // the S gate cycles through the Y and X stabilizers longitudinally, in a
                        // X, Y, -X, -Y pattern, assuming you start in |+>.
                        // That means, if you are a Y stabilizer (you have both X and Z components),
                        // you will be mapped to an X stabilizer with an opposing phase. If you are an X
                        // stabilizer, you will be mapped to a Y stabilizer with the same phase.
                        let generator_x_component = generator.x_bits[*qubit as usize];
                        let generator_z_component = generator.z_bits[*qubit as usize];
                        // flip phase of Y stabilizers.
                        generator.phase_is_negated ^=
                            generator_x_component && generator_z_component;

                        // cycle through X and Y stabilizers.
                        generator.z_bits[*qubit as usize] ^= generator_x_component;
                    }
                }
            }
            Gate::Cx(control, target) => {
                for i in 0..N {
                    for generator in
                        [&mut self.stabilizers[i], &mut self.destabilizers[i]].iter_mut()
                    {
                        // the rules for a CNOT acting on a generator are less intuitive for me. In the heisenberg picture,
                        // CNOT acts on future stabilizers by conjugating them with the CNOT gate. So something like
                        // CNOT * generator * CNOT. This ends up working on the pauli basis like so:
                        // CNOT * Z ⊗ I * CNOT = Z ⊗ I
                        // CNOT * I ⊗ Z * CNOT = Z ⊗ Z
                        // CNOT * Z ⊗ Z * CNOT = I ⊗ Z
                        // CNOT * X ⊗ I * CNOT = X ⊗ X
                        // CNOT * I ⊗ X * CNOT = I ⊗ X
                        // CNOT * X ⊗ X * CNOT = X ⊗ I
                        // and for action on Y operators you can take the product of X and Z cases.
                        generator.x_bits[*target as usize] ^= generator.x_bits[*control as usize];
                        generator.z_bits[*control as usize] ^= generator.z_bits[*target as usize];
                        // we invert the phase if CNOT would negate a pauli operator in the heisenberg picture.
                        // that is to say, something like CNOT * (P1 ⊗ P2) * CNOT = -P1 ⊗ P2.
                        // This happens when the control qubit is stabilized by X, and the target qubit is stabilized by Z.
                        // Because CNOT * (X ⊗ I * I ⊗ Z) * CNOT =
                        // (CNOT * (X ⊗ I) * CNOT)(CNOT * (I ⊗ Z) * CNOT) =
                        // (X ⊗ X)(Z ⊗ Z) or (Z ⊗ Z)(X ⊗ X)
                        // so either
                        // iY ⊗ iY = -(Y ⊗ Y).
                        // or -iY ⊗ -iY = -(Y ⊗ Y).
                        let add_phase_flip = generator.x_bits[*control as usize]
                            && generator.z_bits[*target as usize];
                        // However, if you have an odd balance of X and Y components, the anticommutation rules described
                        // above cancel out. E.g. CNOT(Y ⊗  X)CNOT = Y ⊗ I
                        let anticommutation_parity = generator.z_bits[*control as usize]
                            ^ generator.x_bits[*target as usize]
                            ^ true;
                        generator.phase_is_negated ^= add_phase_flip && anticommutation_parity;
                    }
                }
            }
        }
    }

    fn is_deterministic(&self, qubit: u32) -> bool {
        // are there no stabilizer rows with an X component at the qubit?
        // if so, we're chillin -- we are already in the Z measurement basis because
        // we are either stabilized by Z or -Z, and so either |0> or |1>.
        for i in 0..N {
            if self.stabilizers[i].x_bits[qubit as usize] {
                return false;
            }
        }
        true
    }

    fn pauli_imaginary_phase_exponent(x1: bool, z1: bool, x2: bool, z2: bool) -> i32 {
        // return the sign to which i is raised when the pauli matrices represented by x1*z1 and x2*z2 are multiplied.
        // e.g. X*X = I. X*Z = iY. Z*Z = I. Z*X = -iY. etc.
        // I've used scott aaronson's math here, and it checks out.
        match (x1, z1) {
            (false, false) => 0,
            (true, true) => z2 as i32 - x2 as i32,
            (true, false) => (z2 as i32) * (2 * x2 as i32 - 1),
            (false, true) => (1 - 2 * z2 as i32) * x2 as i32,
        }
    }

    fn rowsum(
        row_h: &mut StabilizerRow<N>,
        row_i: &mut StabilizerRow<N>,
    ) -> Result<(), &'static str> {
        let mut exponent_sum: i32 = 0;
        for j in 0..N {
            exponent_sum += Self::pauli_imaginary_phase_exponent(
                row_i.x_bits[j],
                row_i.z_bits[j],
                row_h.x_bits[j],
                row_h.z_bits[j],
            );
        }
        let pauli_operator_phase =
            2 * (row_h.phase_is_negated as i32) + 2 * (row_i.phase_is_negated as i32);
        let pauli_operator_phase = (pauli_operator_phase + exponent_sum) % 4;
        if pauli_operator_phase == 0 {
            row_h.phase_is_negated = false;
        } else if pauli_operator_phase == 2 {
            row_h.phase_is_negated = true;
        } else {
            // TODO -- maybe use anyhow results and dynamic strings.
            return Err("Non-stabilizer rowsum");
        }
        for j in 0..N {
            row_h.x_bits[j] ^= row_i.x_bits[j];
            row_h.z_bits[j] ^= row_i.z_bits[j];
        }
        Ok(())
    }

    fn determine_deterministic_measurement(&mut self, qubit: u32) -> Result<bool, &'static str> {
        let mut scratch_row = StabilizerRow {
            phase_is_negated: false,
            x_bits: [false; N],
            z_bits: [false; N],
        };
        // try and determine if Z or -Z on the qubit is a stabilizer of the state.
        // TODO: I don't unduerstand this as well as I'd like. Lemme dive in on
        // this point.
        for (destabilizer_row, stabilizer_row) in self
            .destabilizers
            .iter_mut()
            .zip(self.stabilizers.iter_mut())
        {
            if destabilizer_row.x_bits[qubit as usize] {
                Self::rowsum(&mut scratch_row, stabilizer_row)?;
            }
        }
        Ok(scratch_row.phase_is_negated)
    }

    pub fn measure(&mut self, qubit: u32) -> Result<bool, &'static str> {
        if self.measured[qubit as usize] {
            return Err("Qubit already measured");
        }
        self.measured[qubit as usize] = true;
        if self.is_deterministic(qubit) {
            self.determine_deterministic_measurement(qubit)
        } else {
            // uniformly random distribution over {|0>, |1>} since
            // you are stabilized by some X/Y stabilizer, and therefore
            // in an even superposition of |0> and |1>.
            // TODO: change the state after measurement.
            // for now, just permanently collapse measured
            // qubits.
            Ok(self.rand.gen_bool(0.5))
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_i_measured_in_z_basis() {
        let mut stabilizer: StabilizerSimulator<1> = StabilizerSimulator::seeded();
        assert!(!stabilizer.measure(0).unwrap());
    }

    #[test]
    fn test_h_s_s_h_equals_x() {
        let mut stabilizer: StabilizerSimulator<1> = StabilizerSimulator::seeded();
        stabilizer.apply_gate(&Gate::H(0));
        stabilizer.apply_gate(&Gate::S(0));
        stabilizer.apply_gate(&Gate::S(0));
        stabilizer.apply_gate(&Gate::H(0));
        assert!(stabilizer.measure(0).unwrap());
    }

    #[test]
    fn test_cnot_when_control_is_zero() {
        let mut stabilizer: StabilizerSimulator<2> = StabilizerSimulator::seeded();
        stabilizer.apply_gate(&Gate::Cx(0, 1));
        assert!(!stabilizer.measure(0).unwrap());
        assert!(!stabilizer.measure(1).unwrap());
    }

    #[test]
    fn test_cnot_when_control_is_one() {
        let mut stabilizer: StabilizerSimulator<2> = StabilizerSimulator::seeded();
        stabilizer.apply_gate(&Gate::H(0));
        stabilizer.apply_gate(&Gate::S(0));
        stabilizer.apply_gate(&Gate::S(0));
        stabilizer.apply_gate(&Gate::H(0));
        stabilizer.apply_gate(&Gate::Cx(0, 1));
        assert!(stabilizer.measure(0).unwrap());
        assert!(stabilizer.measure(1).unwrap());
    }
}
